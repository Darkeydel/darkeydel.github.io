---
title: "Cross-Site ETag Length Leak"
date: 2025-12-26
categories:
  - Security Research
  - XS-Leaks
  - ETag
---

This technique leaks the length of an ETag from a cross-site page, turning it into an XS-Leak oracle by leveraging 431 errors and History API behavior in Chromium.

## Challenge Overview

A simple note-taking application with:
- `GET /`: Shows notes with search functionality via `query` parameter
- `POST /new`: Creates a note (vulnerable to CSRF)

Goal: Leak the bot's note (flag) without HTML injection, sorting, CSS, or extra resource loading.

## The Solution

### Step 1: ETag Header Length

When the search **hits** the flag note vs **misses**, the response body size differs, causing the ETag to change length.

In this app, ETag is generated by `jshttp/etag`:
```
W/"{{ stat.size.toString(16) }}-{{ stat.mtime.getTime().toString(16) }}"
```

The format includes content size in **hex**. The number of hex digits changes at boundaries (e.g., `0xfff` -> `0x1000`).

By abusing CSRF to create many notes, we can manipulate response size so:
- Search hit: response size `0x1000 + ...` (4 hex digits)
- Search miss: response size `0xfff` (3 hex digits)

This produces a 1-byte difference in ETag length.

### Step 2: 431 Status Error

With a 1-byte difference in ETag length, subsequent requests include:
- Hit: `If-None-Match: W/"1028-7DssyPmtuJFW+hsMczlljuIGJC8"`
- Miss: `If-None-Match: W/"fff-j/5Cw0uvoM8vDCtG7hABgyD9RvM"`

Many web servers enforce a maximum header size (DoS mitigation). If exceeded, returns **431 Request Header Fields Too Large**.

By padding the URL so total header size is near the threshold:
- If header size is under limit: `200 OK`
- If header size is over limit: `431 Request Header Fields Too Large`

### Step 3: History API Behavior

Chromium's session history can be exploited. When navigation to the same URL fails (invalid `page_state`), Chromium **replaces** the current entry instead of pushing a new one.

This means:
- If 431 error occurs: `history.length` increases by 1 (replace)
- If no error: `history.length` increases by 2 (push + push)

By measuring `history.length`, we can detect whether a 431 error occurred!

## Putting It All Together

The exploit combines:
1. CSRF to create many notes, tuning response size near hex boundary
2. URL padding to push second request near header-size threshold
3. Measuring `history.length` to detect 431 errors

The final exploit performs binary search on the flag character by character.

## Other Cases

This technique can also work when:
- Response has ETag vs no ETag
- Using other 4xx errors as oracles

## Software with Variable-Length ETags

- Apache httpd (configurable)
- Nginx
- Tomcat
- H2O

## References

- [Original Research - Takeshi Kaneko](https://blog.arkark.dev/2025/12/26/etag-length-leak)
- [SECCON CTF 2025 Challenge](https://github.com/arkark/my-ctf-challenges)
- [PortSwigger Top 10 2025](https://portswigger.net/research/top-10-web-hacking-techniques-of-2025)
